Refection
Now my solution1 can simulate the real system successfully, including one deadlock situation.
This deadlock happens when there is one tagged bicycle in the inspector and the third bicycle on the belt is also identified by the sensor as tagged at the same time. On one hand, robot is waiting for putting back the inspected bicycle to the third position on the belt. On the other hand, robot is also waiting for taking off the third tagged bicycle from the belt. So, it results a deadlock. This deadlock also may exist in the real factory.
Compared with solution 1, solution2 is more ideal. There is not a deadlock exist in this solution.
This is due to the property of ¡®synchronized¡¯ and ¡¯notifyAll()¡¯. Both scopes are limited to one object. shortBelt.notifyAll() only notifies shortBelt.wait() while Belt.notifyAll() only notifies Belt.wait(). So once tagged is put on the shortBelt, only these relevant threads shortBeltMover and shortBeltConsumer can get the chance to be activated, it is the same to the Belt object. Two objects, shortBelt and Belt, interact though the Robot thread.
in my opinion, the simplest and most direct design is to build corresponding components according to real entities, not only attributes, but also functions.
So, three threads in solution 1, including Sensor, Robot and Inspector, are added.
But I am confused about how to allocate functions to these three threads because robot interacts with sensor, inspector, belt respectively,
then I did the most critical design decision during this assignment, which is that robot is just responsible to its corresponding responsibility in the real factory and the same as other threads.
Another problem I met is that it is nearly impossible to debug multiple threads in Eclipse as one single thread. This confuses me a long time because I can¡¯t find and resolve errors if I can¡¯t debug the program. Then I surfed the internet, read the provided codes and found writing log is a good method to debug concurrency. Actually, the trace of these threads is a kind of debugging to some extent. Even though every time the console log is different, it is correct as long as it is logical.  
By doing this assignment, I not only learn much about how to use basic methods, such as start(),run(),wait() and notifyAll(), to operate multiple threads for concurrency and how they communicate with each other though ¡®synchronized¡¯, but also realize that writing log is a very useful way to debugging, identifying and removing errors. Also, making clear on the appropriate responsibility of each object is critical to the final success.  

